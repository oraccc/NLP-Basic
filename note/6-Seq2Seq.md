## Seq2Seq



### §6.1 Seq2Seq简介

在自然语⾔处理的很多应用中，输入和输出都可以是不定长序列。以机器翻译为例，输入可以是⼀段不定长的英语文本序列，输出可以是一段不定长的法语文本序列，

> 例如：
>
> 英语输入：“They”、“are”、“watching”、“.”
>
> 法语输出：“Ils”、“regardent”、“.”

当输入和输出都是不定长序列时，我们可以使用编码器—解码器（encoder-decoder）或者序列到序列模型（**seq2seq模型**）。这两个模型本质上都用到了两个循环神经网络，分别叫做**编码器**和**解码器**。编码器用来分析输入序列，解码器用来生成输出序列。两个循环神经网络是**共同训练**的。

<img src="https://raw.githubusercontent.com/oraccc/NLP-Basic/master/img/Seq2Seq/translate.png" width="700" />

上图描述了使用编码器—解码器将上述英语句子翻译成法语句子的⼀种方法。

- 在训练数据集中，我们可以在每个句子后附上特殊符号“\<eos>”（end of sequence）以表示序列的终止。
- 编码器每个时间步的输入依次为英语句子中的单词、标点和特殊符号“\<eos>”。上图中使用了编码器**在最终时间步的隐藏状态**作为输⼊句子的表征或编码信息。
- 解码器**在各个时间步中**使用输入句子的编码信息和上个时间步的输出以及隐藏状态作为输入。
- 我们希望解码器在各个时间步能正确依次输出翻译后的法语单词、标点和特殊符号“\<eos>”。
- 需要注意的是，解码器在最初时间步的输入用到了⼀个表示序列开始的特殊符号“\<bos>”（beginning of sequence）。

---



### §6.2 编码器与解码器

#### :one:编码器

编码器的作用是把⼀个不定长的输入序列**变换成⼀个定长的背景变量** $c$，并在该背景变量中编码输入序列信息。

常用的编码器是**循环神经网络**。

- 让我们考虑批量大小为 $1$ 的时序数据样本。假设输入序列是 $x_1,...,x_T$，例如 $x_i$ 是输入句子中的第 $i$ 个词。

- 在时间步 $t$，循环神经网络将输入 $x_t$ 的特征向量 $x_t$ 和上个时间步的隐藏状态 $h_{t-1}$ 变换为当前时间步的隐藏状态 $h_t$。我们可以用函数 $f$ 表达循环神经网络隐藏层的变换：

$$
  h_t = f(x_t, h_{t-1})
$$

- 接下来，编码器通过自定义函数 $q$ 将**各个时间步的隐藏状态变换为背景变量**：

$$
c=q(h1, ..., h_T)
$$

- 例如，当选择 $q(h_1,...,h_T ) = h_T $时，背景变量是输入序列最终时间步的隐藏状态 $h_T$。

以上描述的编码器是⼀个单向的循环神经网络，每个时间步的隐藏状态只取决于该时间步及之前的输入子序列。我们也可以使用双向循环神经网络构造编码器。在这种情况下，编码器每个时间步的隐藏状态同时**取决于该时间步之前和之后的子序列**（包括当前时间步的输入），并编码了整个序列的信息。

#### :two:解码器

编码器输出的背景变量 $c$ 编码了整个输入序列 $x_1,...,x_T$ 的信息。

给定训练样本中的输出序列 $y_1, y_2,..., y_{T^′} $，对每个时间步 $t^′$（符号与输入序列或编码器的时间步 $t$ 有区别），解码器输出 $y_{t^′}$ 的条件概率将基于之前的输出序列 $y_1,...,y_{t^′}$ 和背景变量 $c$，即：
$$
P(y_{t^′}|y_1,...y_{t^′-1},c)
$$

- 为此，我们可以使用另⼀个**循环神经网络**作为解码器。

- 在输出序列的时间步 $t^′$，解码器将上⼀时间步的输出以及背景变量 $c$ 作为输入，并将它们与上⼀时间步的隐藏状态变换为当前时间步的隐藏状态 $s_{t^′}$。因此，我们可以用函数 $g$ 表达**解码器隐藏层的变换**：

$$
s_{t^′}=g(y_{t^′-1},c,s_{t^′-1})
$$

- 有了解码器的隐藏状态后，我们可以使用自定义的输出层和softmax运算来计算 $P(y_{t^′}|y_1,...y_{t^′-1},c)$ 。例如，基于当前时间步的解码器隐藏状态 $s_{t^′}$、上⼀时间步的输出$s_{t^′-1}$以及背景变量 $c$ 来计算当前时间步输出 $y_{t^′}$ 的概率分布。

---



### §6.3 Seq2Seq模型训练与预测

#### :one:训练模型

根据最大似然估计，我们可以最大化输出序列基于输入序列的条件概率


$$
P(y_1,...,y_{t^′-1}|x_1,...,x_T) = \prod_{t^′=1}^{T^′} P(y_{t^′}|y_1,...,y_{t^′-1},x_1,...,x_T) \\
=\prod_{t^′=1}^{T^′}P(y_{t^′}|y_1,...,y_{t^′-1},c)
$$

并得到该输出序列的损失

$$
-logP(y_1,...,y_{t^′-1}|x_1,...,x_T) =-\sum_{t^′=1}^{T^′}logP(y_{t^′}|y_1,...,y_{t^′-1},c)
$$

在模型训练中，所有输出序列损失的均值通常作为需要最小化的损失函数。在上图所描述的模型预测中，我们需要将解码器在上⼀个时间步的输出作为当前时间步的输入。

与此不同，在训练中我们也可以将标签序列（训练集的真实输出序列）在上⼀个时间步的标签作为解码器在当前时间步的输入。这叫作**强制教学**（teacher forcing）。

#### :two:模型预测

以上介绍了如何训练输入和输出均为不定长序列的编码器—解码器。本节我们介绍如何使用编码器—解码器来预测不定长的序列。

在准备训练数据集时，我们通常会在样本的输入序列和输出序列后面分别附上⼀个特殊符号“\<eos>”表示序列的终止。为了便于讨论，假设解码器的输出是⼀段文本序列。设输出文本词典 $Y$（包含特殊符号“\<eos>”）的大小为 $|Y|$，输出序列的最大长度为$T^′$。所有可能的**输出序列⼀共有 $O(|y|^{T^′})$种**。这些输出序列中所有特殊符号“\<eos>”后面的子序列将被舍弃。

##### Method 1: 贪婪搜索

- 对于输出序列**任⼀时间步** $t^′$，我们从 $|Y|$ 个词中搜索出条件概率最大的词作为输出。

$$
y_{t^′}=argmax_{y \in Y}P(y|y_1,...,y_{t^′-1},c)
$$
- ⼀旦搜索出“\<eos>”符号，或者输出序列长度已经达到了最大长度$T^′$，便完成输出。

- 我们在描述解码器时提到，基于输入序列生成输出序列的条件概率是 $\prod_{t^′=1}^{T^′} P(y_{t^′}|y_1,...,y_{t^′-1},c)$ 我们将该条件概率最大的输出序列称为**最优输出序列**。

而**贪婪搜索的主要问题是不能保证得到最优输出序列**。

> 假设输出词典里面有“A”, “B”, “C”和“\<eos>”这4个词。下图中每个时间步下的4个数字分别代表了该时间步生成“A”, “B”, “C”和“\<eos>”这4个词的条件概率。在每个时间步，贪婪搜索选取条件概率最大的词。因此，下图中将生成输出序列 `A, B, C, <eos>`。该输出序列的条件概率是 $0.5 × 0.4 × 0.4 × 0.6 = 0.048$。

<img src="https://raw.githubusercontent.com/oraccc/NLP-Basic/master/img/Seq2Seq/example1.png" width="350" />

##### Method 2: 穷举搜索

##### Method 3: 束搜索